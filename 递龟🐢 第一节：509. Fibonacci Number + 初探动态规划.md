# 递龟🐢 第一节：509. Fibonacci Number的多种解法

## 什么是 recursion 递龟🐢？不打比方，直接上干货！

递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环。

### 我们要记住的是，想要用递归必须知道两个条件：1. 递归出口(终止递归的条件)  2.递归表达式(规律)

#### 例子1: 1+2+3+...+n
首先，我们来找出它的规律：1+2+3+...+n，这是一个求和的运算，那么我们可以假设X=1+2+3+...+n，可以将1+2+3+...+(n-1)看成是一个整体。而这个整体做的事又和我们的初始目的(求和)相同。以我们的高中数学知识我们又可以将上面的式子看成X=sum(n-1)+n

好了，我们找到我们的递归表达式(规律)，它就是sum(n-1)+n,那递归出口呢，这个题目的递归出口就有很多了，我列举一下：

- 如果n=1时，那么就返回1
- 如果n=2时，那么就返回3(1+2)
- 如果n=3时，那么就返回6(1+2+3)

当然了，我肯定是使用一个最简单的递归出口了：if(n=1) return 1
```
public static int sum(int n) {

        if (n == 1) {
            return 1;
        } else {
            return sum(n - 1) + n;
        }
    }
```
如果递归出口为4，(1+2+3+4)
```
public static int sum(int n) {

        if (n == 4) {
            return 10;
        } else {
            return sum(n - 1) + n;
        }
    }
```
有了这个例子，我们就知道，递归就是要建模！ 还有什么要建模但你不会的？动态规划呀！ 

#### 例子2:数组内部的最大值 --- “当有数组了，有什么处理技巧？LR边界法”

- 建模： 我们又可以运用1和整体的思想来找到规律将数组第一个数->2与数组后面的数->{3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}进行切割，将数组后面的数看成是一个整体X={3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}，那么我们就可以看成是第一个数和一个整体进行比较 if(2>X) return 2 else(2<X) return X而我们要做的就是找出这个整体的最大值与2进行比较。找出整体的最大值又是和我们的初始目的 (找出最大值)是一样的也就可以写成if( 2>findMax() )return 2 else return findMax() 递归出口，如果数组只有1个元素时，那么这个数组最大值就是它了。使用到数组的时候，我们通常为数组设定左边界和右边界，这样比较好地进行切割L表示左边界，往往表示的是数组第一个元素，也就会赋值为0(角标为0是数组的第一个元素)R表示右边界，往往表示的是数组的长度，也就会赋值为arrays.length-1（长度-1在角标中才是代表最后一个元素).

```
public static int findMax(int[] arrays, int L, int R) {

        //如果该数组只有一个数，那么最大的就是该数组第一个值了
        if (L == R) {
            return arrays[L];
        } else {

            int a = arrays[L];
            int b = findMax(arrays, L + 1, R);//找出整体的最大值

            if (a > b) {
                return a;
            } else {
                return b;
            }
        }

    }
```

#### 例子3: 冒泡排序递归写法 

冒泡排序：俩俩交换，在第一趟排序中能够将最大值排到最后面，外层循环控制排序趟数，内层循环控制比较次数。

- 建模：当第一趟排序后，我们可以将数组最后一位(R)和数组前面的数(L,R-1)进行切割，数组前面的数(L,R-1)看成是一个整体，这个整体又是和我们的初始目的

(找出最大值，与当前趟数的末尾处交换)是一样的。

- 递归出口：当只有一个元素时，即不用比较了：L==R

```

public static void bubbleSort(int[] arrays, int L, int R) {

        int temp;

        //如果只有一个元素了，那什么都不用干
        if (L == R) ;

        else {
            for (int i = L; i < R; i++) {
                if (arrays[i] > arrays[i + 1]) {
                    temp = arrays[i];
                    arrays[i] = arrays[i + 1];
                    arrays[i + 1] = temp;
                }
            }

            //第一趟排序后已经将最大值放到数组最后面了

            //接下来是排序"整体"的数据了
            bubbleSort(arrays, L, R - 1);

        }
    }
```


#### 例子4: 509. Fibonacci Number

作者：labuladong
链接：https://leetcode-cn.com/problems/fibonacci-number/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-labuladong/

##### 方法一：单纯的递归建模
- 建模： F(N) = F(N - 1) + F(N - 2), for N > 1 
- 递归出口：F(0) = 0, F(1) = 1

我们的原始递归🐢代码如下：
```
class Solution {
    public int fib(int N) {
        
        if (N == 0) {
            return 0;
        }
        
        if (N == 1) {
            return 1;
        }
        
        return fib(N-1) + fib(N-2);   
    }
}
```

这个原始递🐢方法写出来了，那么能不能优化它呢？斐波那契不是严格意义上的DP问题，因为它没有求出最值。而DP一般是要求最值的。

PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。

##### 方法二：带备忘录的递归解法 memoization

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.

带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

```
class Solution {
    public int fib(int N) {
        
        int [] array = new int [N+1];
        return helper (array, N);
        
    }
    
    //private int[] helper (int[] array, int N) {
    //没有必要return int[]， 因为是个全局变量，parameter呀！
    
    private int helper (int[] array, int N) {
     
         if (N == 0 || N == 1) {
            return N;
        }
        
        //如果已经被存在array里面了，那么就直接return
         if (array[N] != 0) {
             return array[N];
         }
       
        //转移方程
         array[N] = helper (array, N-1) + helper (array, N-2);
        
         return array[N]; 
        
    }
}
```

子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。


##### 方法三：dp 数组的迭代解法

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

```
class Solution {
    public int fib(int N) {
        
        if (N == 0 || N == 1) { 
            return N;
        }
        
        int prev1 = 1;
        int prev2 = 0;
        int result = prev1 + prev2;
        
        for (int i = 2; i < N+1; i++) {
            result = prev1 + prev2;
            prev2 = prev1;
            prev1 = result;
        }
        
         return result; 
    }
}
```


