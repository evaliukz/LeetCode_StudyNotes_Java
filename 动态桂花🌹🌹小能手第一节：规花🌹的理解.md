# 立个Flag：我要当动态规花🌹小能手！Yes you can! 

## 什么动态规划呀？这就是高中数列题！开个空间填满数去换时间！

动态规划就是把一个大问题拆解成一堆小问题...任何大问题都能被拆成小问题，但是动态规划取决于 -- 这些小问题会不会被重复调用！**缓存小结果，之后要用到 - 用空间换时间**

什么问题适合用DP
* 求最大值/最小值
* 求可不可行
* 求方案总数

如果一个问题问求出“所有的方案和结果”，那**肯定不是动态规划**，大概率是DFS递归和回溯。

## 动态规划：

### 1.确定状态：动态规划就是开一个DP空间，然后填满这个空间，中间如果有填不上的就用一个统一的数字填上
   
   确定状态需要两个意识: 
   - 最后一步：
      *最优策略：问题求什么？最大？最小？最全？原则：没有遗漏，没有重复
      *无后效性： 就是我们只关心子问题i这一步的最优值，而不关心这个最优值是怎么来的。这个DP状态无论是怎么得到的，都不影响后面DP状态的取值。
   
   - 最后一步再倒退一步得到子问题
                      
### 2. 转移方程：根据子问题得到

### 3. 初始条件和边界情况：要细心

 *什么时候停下来？
 *小于0怎么办？
 *如果某个值不存在怎么办？

### 4. 计算顺序: 从小到大（一般来说是这个），从大到小

空间复杂度就是开的数组。

### 例题：322. Coin Change

1. 确定状态：最优策略是最小，所以Math.min()

   最后一步：f(11) = min [f(11-1)+1,f(11-2)+1,f(11-5)+1] 这个没有后效性，而且每一步递增都是选择+1，这样代表的是coin的数目

2. 转移方程：

F(i)	最小硬币数量

- F(0)	0 //金额为0不能由硬币组成
- F(1)	1 //F(1)=min(F(1-1),F(1-2),F(1-5))+1=1F(1)=min(F(1−1),F(1−2),F(1−5))+1=1
- F(2)	1 //F(2)=min(F(2-1),F(2-2),F(2-5))+1=1F(2)=min(F(2−1),F(2−2),F(2−5))+1=1
- F(3)	2 //F(3)=min(F(3-1),F(3-2),F(3-5))+1=2F(3)=min(F(3−1),F(3−2),F(3−5))+1=2
- F(4)	2 //F(4)=min(F(4-1),F(4-2),F(4-5))+1=2F(4)=min(F(4−1),F(4−2),F(4−5))+1=2
- ...	...
- F(11)	3 //F(11)=min(F(11-1),F(11-2),F(11-5))+1=3F(11)=min(F(11−1),F(11−2),F(11−5))+1=3

转移方程: f(amount) = Min [f(amount - coins[1]),...f(amount - coins[j])}

3. 初始条件和边界情况：要细心

- 什么时候停下来？  当f[amount]时候就可以停下来return f[amount]
- 小于0怎么办？  如果小于0，f[i]就可以填上Integer.MAX_VALUE， 但是如果填上amount+1就最好了，因为就算是全是1，数目也不会超过amount
- 如果某个值不存在怎么办？ 也填上amount+1就好了

4. 计算顺序：由小到大

```
class Solution {
    public int coinChange(int[] coins, int amount) {
        //转移方程: f(amount) = Min [f(amount - coins[1]),...f(amount - coins[j])}
        
        int m = coins.length;
        int [] dp = new int[amount+1]; //开记忆数组
        //Arrays.fill(function, Integer.MAX_VALUE);
        
        dp[0] = 0; //一开始没通过是因为没有写这个，下面for循环也是要 i=1开始
        
        for (int i = 1; i<= amount; i++) {
            dp[i] = amount+1; //用这个就好，比Arrays.fill会有效率
            
            for (int j = 0; j< m; j++) { //1,2,5
                int coin = coins[j];
                
                //if (i-coin < 0) continue; 这么写很麻烦啊
                // function[i-coin] != amount+1这个写的很有效率
                // 这个就是用来fill这个dp空间
                if (i-coin >= 0 && dp[i-coin] != amount+1){ 
                    dp[i] = Math.min(dp[i], dp [i - coin]+1);
                }
            }
        }
        
        if (dp[amount] == amount+1) {
            return -1;
        } else {
            return dp[amount];
        }
    }
}
```

## 动态规花🌹问题类别：

### 1. 线性DP ：序列，双序列，一维数组，二维坐标系，背包问题
### 2. 区间DP
### 3. 划分DP
### 3. 树形DP(一般不出现）
### 4. 状压DP(一般不出现）
### 5. 数位DP

## 动态规划的优化：
### 1. RMQ优化
### 2. 单调队列优化
### 3. 矩阵快速幂优化
### 4. 斜率优化
### 5. 四边形不等式优化
### 6. 决策单调性优化
