# 递龟🐢 第一节：509. Fibonacci Number的多种解法

## 什么是 recursion 递龟🐢？不打比方，直接上干货！

递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环。

### 我们要记住的是，想要用递归必须知道两个条件：1. 递归出口(终止递归的条件)  2.递归表达式(规律)

#### 例子1: 1+2+3+...+n
首先，我们来找出它的规律：1+2+3+...+n，这是一个求和的运算，那么我们可以假设X=1+2+3+...+n，可以将1+2+3+...+(n-1)看成是一个整体。而这个整体做的事又和我们的初始目的(求和)相同。以我们的高中数学知识我们又可以将上面的式子看成X=sum(n-1)+n

好了，我们找到我们的递归表达式(规律)，它就是sum(n-1)+n,那递归出口呢，这个题目的递归出口就有很多了，我列举一下：

- 如果n=1时，那么就返回1
- 如果n=2时，那么就返回3(1+2)
- 如果n=3时，那么就返回6(1+2+3)

当然了，我肯定是使用一个最简单的递归出口了：if(n=1) return 1
```
public static int sum(int n) {

        if (n == 1) {
            return 1;
        } else {
            return sum(n - 1) + n;
        }
    }
```
如果递归出口为4，(1+2+3+4)
```
public static int sum(int n) {

        if (n == 4) {
            return 10;
        } else {
            return sum(n - 1) + n;
        }
    }
```
有了这个例子，我们就知道，递归就是要建模！ 还有什么要建模但你不会的？动态规划呀！ 

#### 例子2:数组内部的最大值 --- “当有数组了，有什么处理技巧？LR边界法”

- 建模： 我们又可以运用1和整体的思想来找到规律将数组第一个数->2与数组后面的数->{3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}进行切割，

将数组后面的数看成是一个整体X={3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}，那么我们就可以看成是第一个数和一个整体进行比较

if(2>X) return 2 else(2<X) return X而我们要做的就是找出这个整体的最大值与2进行比较。找出整体的最大值又是和我们的初始目的

(找出最大值)是一样的也就可以写成if( 2>findMax() )return 2 else return findMax() 递归出口，如果数组只有1个元素时，那么

这个数组最大值就是它了。使用到数组的时候，我们通常为数组设定左边界和右边界，这样比较好地进行切割L表示左边界，往往表示的是数组第

一个元素，也就会赋值为0(角标为0是数组的第一个元素)R表示右边界，往往表示的是数组的长度，也就会赋值为arrays.length-1（长度-1在

角标中才是代表最后一个元素).

```
public static int findMax(int[] arrays, int L, int R) {

        //如果该数组只有一个数，那么最大的就是该数组第一个值了
        if (L == R) {
            return arrays[L];
        } else {

            int a = arrays[L];
            int b = findMax(arrays, L + 1, R);//找出整体的最大值

            if (a > b) {
                return a;
            } else {
                return b;
            }
        }

    }
```

#### 例子3: 冒泡排序递归写法 

冒泡排序：俩俩交换，在第一趟排序中能够将最大值排到最后面，外层循环控制排序趟数，内层循环控制比较次数。

- 建模：当第一趟排序后，我们可以将数组最后一位(R)和数组前面的数(L,R-1)进行切割，数组前面的数(L,R-1)看成是一个整体，这个整体又是和我们的初始目的

(找出最大值，与当前趟数的末尾处交换)是一样的。

- 递归出口：当只有一个元素时，即不用比较了：L==R

```

public static void bubbleSort(int[] arrays, int L, int R) {

        int temp;

        //如果只有一个元素了，那什么都不用干
        if (L == R) ;

        else {
            for (int i = L; i < R; i++) {
                if (arrays[i] > arrays[i + 1]) {
                    temp = arrays[i];
                    arrays[i] = arrays[i + 1];
                    arrays[i + 1] = temp;
                }
            }

            //第一趟排序后已经将最大值放到数组最后面了

            //接下来是排序"整体"的数据了
            bubbleSort(arrays, L, R - 1);

        }
    }
```


#### 例子4: 509. Fibonacci Number

- 建模： F(N) = F(N - 1) + F(N - 2), for N > 1 
- 递归出口：F(0) = 0, F(1) = 1

我们的原始递归🐢代码如下：
```
class Solution {
    public int fib(int N) {
        
        if (N == 0) {
            return 0;
        }
        
        if (N == 1) {
            return 1;
        }
        
        return fib(N-1) + fib(N-2);   
    }
}
```
